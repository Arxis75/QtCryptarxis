#pragma once

#include <data/System.h>

template <class Derived, typename T = uint8_t> 
class ValueVector
{
    public:
        ValueVector() { vvalue.reserve(isAligned() ? 32 : 256); }

        template<class D, typename U>
        ValueVector(const ValueVector<D, U>& v);
    
        inline void push_back(T elem) { vvalue.push_back(elem); }

        inline operator const vector<uint8_t>&() const { return vvalue; }
        inline uint8_t operator[](uint64_t elem_index) const { return vvalue[elem_index]; };

        inline uint64_t nbElements() const { return vvalue.size(); }
        //inline uint64_t bytesToNbElements(uint64_t bytes) const { return ((bytes << 3) / elementBitSize()); }
        inline uint8_t elementBitSize() const { return isAligned() ? 8 : 1; }
        inline uint64_t containerBitSize() const { return nbElements()*elementBitSize(); }
        //inline uint64_t containerByteSize() const { return (containerBitSize() >> 3); }

        inline bool isAligned() const { return typeid(T) == typeid(uint8_t); }

        inline bool getBit(uint64_t bit_offset) const { return (1 << (bit_offset % elementBitSize())) & vvalue[(containerBitSize() - 1 - bit_offset) / elementBitSize()]; }
        inline void setBit(uint64_t bit_offset, bool bit_value) { vvalue[(containerBitSize() - 1 - bit_offset) / elementBitSize()] |= (bit_value << (bit_offset % elementBitSize())); }

    private:
        vector<uint8_t> vvalue;
};

template <class Derived, typename T>
template<class D, typename U>
ValueVector<Derived, T>::ValueVector(const ValueVector<D, U>& v)
{
    if(isAligned() == v.isAligned())
        //Same alignment
        vvalue = v;
    else {
        //Different alignment => bit per bit copy + byte-alignment
        div_t v_byte_size = div(v.containerBitSize(), 8);
        uint64_t v_aligned_bit_size = (v_byte_size.quot<<3) + (v_byte_size.rem ? 8 : 0);
        vvalue.resize(v_aligned_bit_size/elementBitSize());
        for(uint64_t i = 0 ; i < v.containerBitSize() ; i++)
            setBit(i, v.getBit(i));
    }
}